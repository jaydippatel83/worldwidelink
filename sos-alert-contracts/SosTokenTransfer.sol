// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

// AutomationCompatible.sol imports the functions from both ./AutomationBase.sol and
// ./interfaces/AutomationCompatibleInterface.sol
import "@chainlink/contracts/src/v0.8/automation/AutomationCompatible.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "./ExternalRequestContract.sol";

/**
 * @dev Example contract, use the Forwarder as needed for additional security.
 *
 * @notice important to implement {AutomationCompatibleInterface}
 */

/**
 * THIS IS AN EXAMPLE CONTRACT THAT USES HARDCODED VALUES FOR CLARITY.
 * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.
 * DO NOT USE THIS CODE IN PRODUCTION.
 */

contract SosTokenTransfer is AutomationCompatibleInterface {
    /**
     * Public counter variable
     */
    uint256 public counter;
    address public tokenAddress; 

    struct alert{
        string email;
        address walletAddress;
        uint256 inactivityThreshold;
        string message;
        uint256 triggerVal;
    }

    /**
     * Use an interval in seconds and a timestamp to slow execution of Upkeep
     */
    uint256 public immutable interval;
    uint256 public lastTimeStamp;

    mapping(address => uint256) public lastLoginTime;
    mapping(address => alert) public alerts;
    address[] public users;

     ExternalRequestContract public externalRequest;

    constructor(uint256 updateInterval, address _tokenAddress, address _externalRequest) {
        interval = updateInterval;
        lastTimeStamp = block.timestamp;
        tokenAddress = _tokenAddress;
        externalRequest = ExternalRequestContract(_externalRequest);
        counter = 0;
    }

     function userExists(address user) public view returns (bool) {
        for (uint256 i = 0; i < users.length; i++) {
            if (users[i] == user) {
                return true;
            }
        }
        return false;
    }

    function recordLogin() external {
        lastLoginTime[msg.sender] = block.timestamp;
        if(!userExists(msg.sender)){
           users.push(msg.sender);
        }
       
    }

    function setAlert(address user, string memory email, uint256 inactivityThreshold, string memory message, uint256 triggerVal) external {
         alert memory newAlert = alert(email, user, inactivityThreshold, message, triggerVal);
         alerts[user] = newAlert;
    }

    function checkUpkeep(
        bytes calldata /* checkData */
    )
        external
        view
        override
        returns (bool upkeepNeeded, bytes memory /* performData */)
    {
        upkeepNeeded = (block.timestamp - lastTimeStamp) > interval;
        // We don't use the checkData in this example. The checkData is defined when the Upkeep was registered.
    }

     function tokenTranfer(address user) internal returns(bool) {
        uint256 balance = IERC20(tokenAddress).balanceOf(address(this));
        require(balance > 0, "Insufficient balance");
        IERC20 token = IERC20(tokenAddress);
        bool transferSuccess = token.transfer(user, balance);
        return transferSuccess;
    }

    function performUpkeep(bytes calldata /* performData    */) external override {
        if ((block.timestamp - lastTimeStamp) > interval) {
            lastTimeStamp = block.timestamp;
           
             for(uint256 i = 0; i < users.length; i++){
               
                uint256 lastLogin = lastLoginTime[users[i]];
            
                if(block.timestamp - lastLogin > alerts[users[i]].inactivityThreshold){
                   counter = counter + 1;
                   if(alerts[users[i]].triggerVal == 2){
                    bool transferResult = tokenTranfer(users[i]);
                    if (transferResult) {
                        externalRequest.requestInfo(alerts[users[i]].message, alerts[users[i]].email);
                     }
                   }else{
                     externalRequest.requestInfo(alerts[users[i]].message, alerts[users[i]].email);
                   }
                }
             }
           
        }
        // We don't use the performData in this example. The performData is generated by the Automation Node's call to your checkUpkeep function
    }

    function getCurrentTimeStamp() external view returns(uint256){
        return  block.timestamp;
    }

    function getUsers() external view returns(address[] memory){
        return users;
    }
}